"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPlugin = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _mkdirp = require("mkdirp");

var _mkdirp2 = _interopRequireDefault(_mkdirp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var initialOptions = {
  taggerModule: "tagger",
  taggedPrefix: "",
  taggedSuffix: "",
  outputPath: _path2.default.join(__dirname, "../output"),
  outputFileExtension: "txt",
  taggerMembers: {}
};

var fixOptions = function fixOptions(_ref) {
  var taggerModule = _ref.taggerModule,
      taggerModules = _ref.taggerModules,
      options = _objectWithoutProperties(_ref, ["taggerModule", "taggerModules"]);

  return taggerModule || taggerModules ? _extends({}, options, {
    taggerModules: (taggerModules || []).concat(taggerModule || [])
  }) : options;
};

var createPlugin = exports.createPlugin = function createPlugin() {
  var createOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (_ref2) {
    var t = _ref2.types;

    var data = {};

    var getOptions = function getOptions(stateOptions) {
      var taggerMembers = _extends({}, initialOptions.taggerMembers, createOptions.taggerMembers, stateOptions.taggerMembers);

      var defaultOptions = _extends({}, fixOptions(initialOptions), fixOptions(createOptions), fixOptions(stateOptions), {
        taggerMembers: null,
        taggerMember: null
      });

      var options = Object.keys(taggerMembers).sort(function (a) {
        return a === "*" ? 1 : 0;
      }).map(function (member) {
        return _extends({}, defaultOptions, fixOptions(taggerMembers[member]), {
          taggerMember: member
        });
      }).concat(defaultOptions);

      return options.length ? options : [defaultOptions];
    };

    var isTaggerModule = function isTaggerModule(source) {
      return data.options.some(function (opts) {
        return opts.taggerModules.indexOf(source) !== -1;
      });
    };

    var findTagOptions = function findTagOptions(_ref3) {
      var _ref3$member = _ref3.member,
          member = _ref3$member === undefined ? null : _ref3$member;
      return data.options.find(function (opts) {
        return opts.taggerMember === member || member !== null && opts.taggerMember === "*";
      });
    };

    var getTagProps = function getTagProps(tag) {
      if (t.isIdentifier(tag)) {
        return {
          name: tag.name,
          member: null
        };
      } else if (t.isMemberExpression(tag)) {
        return {
          name: tag.object.name,
          member: tag.property.name
        };
      } else if (t.isCallExpression(tag)) {
        return getTagProps(tag.callee);
      }

      return {};
    };

    var findTagger = function findTagger(name) {
      return data.taggers.find(function (tagger) {
        return tagger.name === name;
      });
    };

    var getRelativeOutputFilePath = function getRelativeOutputFilePath(outputFilePath) {
      var path = _path2.default.relative(_path2.default.dirname(data.filename), outputFilePath).replace(/\\/g, "/");
      return path.charAt(0) !== "." ? "./" + path : path;
    };

    return {
      visitor: {
        Program: function Program(path, state) {
          var filename = path.hub.file.opts.filename;
          if (!filename) {
            throw path.buildCodeFrameError("Filename required");
          }

          data.options = getOptions(state.opts);
          data.filename = filename;
          data.taggers = [];
          data.insertPath = null;
          // TODO validate options
        },
        ImportDeclaration: function ImportDeclaration(path) {
          var source = path.node.source.value;
          if (isTaggerModule(source)) {
            var importPath = path;

            path.traverse({
              ModuleSpecifier: function ModuleSpecifier(path) {
                var tagger = {
                  importPath: importPath,
                  name: path.node.local.name
                };
                data.taggers = data.taggers.concat(tagger);

                if (!data.insertPath) {
                  data.insertPath = importPath;
                }
              }
            });
          }
        },
        TaggedTemplateExpression: function TaggedTemplateExpression(path) {
          var tag = path.node.tag;

          var tagProps = getTagProps(tag);
          var options = findTagOptions(tagProps);
          var tagger = findTagger(tagProps.name);

          if (tagger && options) {
            // check if the tagger is from the import (root) scope
            // assuming we only need to check imports
            var binding = path.scope.getBinding(tagger.name);
            if (binding.scope.uid !== tagger.importPath.scope.uid) {
              return;
            }

            // don't allow tag expressions
            var _path$node$quasi = path.node.quasi,
                expressions = _path$node$quasi.expressions,
                quasis = _path$node$quasi.quasis;

            if (expressions.length !== 0 || quasis.length !== 1) {
              throw path.buildCodeFrameError("No expressions allowed");
            }

            var taggedContent = quasis[0].value.cooked;
            var outputContent = options.taggedPrefix + taggedContent + options.taggedSuffix;

            var file = _path2.default.parse(data.filename);
            var relativePath = _path2.default.relative(options.outputPath, file.dir);
            var strippedPath = relativePath.replace(/\.\./g, ".");
            var outputPath = _path2.default.join(options.outputPath, strippedPath);
            var tagId = path.scope.generateUid("tag");
            var tagIdIdentifier = t.identifier(tagId);
            var tagArguments = [tagIdIdentifier];
            var outputFilename = file.name + tagId + "." + options.outputFileExtension;
            var outputFilePath = _path2.default.join(outputPath, outputFilename);

            var initialTaggedProps = {
              source: data.filename,
              tag: tagProps,
              tagOptions: options,
              tagId: tagId,
              tagIdIdentifier: tagIdIdentifier,
              tagArguments: tagArguments,
              taggedContent: taggedContent,
              outputContent: outputContent,
              outputFilePath: outputFilePath
            };

            var taggedProps = options.taggedCallback ? _extends({}, initialTaggedProps, options.taggedCallback(initialTaggedProps, t)) : initialTaggedProps;

            // write tagged string to output file
            // TODO check for write failure
            // TODO optionally check unique content collision
            _mkdirp2.default.sync(_path2.default.dirname(taggedProps.outputFilePath));
            _fs2.default.writeFileSync(taggedProps.outputFilePath, taggedProps.outputContent);

            // replace tagged template expression with tagger function call
            path.replaceWith(t.callExpression(t.cloneDeep(tag), taggedProps.tagArguments));

            // add import of output file
            var hasTagId = taggedProps.tagArguments.some(function (a) {
              return t.shallowEqual(a, tagIdIdentifier);
            });
            var importSpecifiers = hasTagId ? [t.importDefaultSpecifier(tagIdIdentifier)] : [];
            var relativeOutputFilePath = getRelativeOutputFilePath(taggedProps.outputFilePath);
            data.insertPath.insertBefore(t.importDeclaration(importSpecifiers, t.stringLiteral(relativeOutputFilePath)));
          }
        }
      }
    };
  };
};

exports.default = createPlugin();